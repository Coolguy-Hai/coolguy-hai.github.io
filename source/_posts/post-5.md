---
title: 【C++面试】
date: 2021-06-14 14:37:54
tags: CPP
---

## 操作系统

1. 进程间的通信方式

   [张三同学没答好「进程间通信」，被面试官挂了.... - 小林coding的文章 - 知乎](https://zhuanlan.zhihu.com/p/165224175)

   > 1. 管道
   >
   >    匿名管道只能用于存在父子关系的进程间通信。
   >
   > 2. 消息队列
   >
   > 3. 共享内存
   >
   > 4. 信号量
   >
   > 5. socket

2. 进程和线程的区别

   > ### 1. 定义    
   >
   > 看了下面的定义，可能会有点晕，但我还是要把他写下来（为了严谨）。
   >  **进程**是资源（CPU、内存等）分配的基本单位，具有一定**独立**功能的程序关于某个数据集合上的一次运行活动，进程是系统进行**资源分配和调度**的一个独立单位。
   >  **线程**是进程的一个实体，是**独立运行和独立调度**的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的**线程共享**进程所拥有的全部资源。
   >
   > ### 2.区别  
   >
   > 1. 进程是资源分配的基本单位；线程是程序执行的基本单位。
   > 2. 进程拥有自己的资源空间，没启动一个进程，系统就会为它分配地址空间；而线程与CPU资源分配无关，多个线程共享同一进程内的资源，使用相同的地址空间。
   > 3. 一个进程可以包含若干个线程。
   >
   > ### 3. 优劣    
   >
   > 正是因为这二者有区别，所以带来的各自的优劣
   > 
   >
   > 1. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（Inter Process Communication，IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
   > 2. 线程的调度与切换比进程快很多，同时创建一个线程的开销也比进程要小很多。
   > 3. 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

3. 程序的内存布局

   [浅谈程序的内存布局 - herongwei的文章 - 知乎](https://zhuanlan.zhihu.com/p/77122692)

   > **栈：** 栈用于维护函数调用的上下文，离开了栈，函数调用就无法实现，栈通常在用户空间的最高地址处分配，通常有数兆字节的大小。
   >
   > **堆：** 堆是用来容纳应用程序动态分配的内存区域，当程序使用 malloc 或者 new 分配内存的时候，得到的内存会来自堆里。堆通常存在栈的下方（低地址方向），在某些时候，堆也可能没有固定统一的存储区域。堆一般比栈大很多，可以有几十至数百兆字节的容量。
   >
   > **可执行文件映像：** 存储着可执行文件在内存里的映像，由装载器在装载时将可执行文件的内存读取或映射到这里。
   >
   > **保留区：** 保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称：例如大多数操作系统中，极小的地址通常都是不允许访问的，如 NULL，C 语言将无效指针赋值为 0 也是这个考虑。
   >
   > **动态链接库映射区：** 这个区域用于映射装载的动态链接库。在 Linux 下，如果可执行文件依赖其它共享库，那么系统就会为它在从 0x40000000 开始的地址分配相应的空间，并将共享库载入该空间。
   > 剩下的还有以下几部份组成：
   > （1）代码段
   > （2）初始化数据段（数据段）
   > （3）未初始化数据段（BSS 段）

4. malloc的底层实现

   [malloc实现原理 | 罗道文的私房菜 (luodw.cc)](http://luodw.cc/2016/02/17/malloc/)

   malloc通过brk()和mmap()系统调用来实现内存分配，其中brk()通过调整堆的上界，mmap()向映射区申请一块内存。

   当申请小内存的时，malloc使用sbrk分配内存；当申请大内存时，使用mmap函数申请内存；但是这只是分配了虚拟内存，还没有映射到物理内存，当访问申请的内存时，才会因为缺页异常，内核分配物理内存。

   由于brk/sbrk/mmap属于系统调用，如果每次申请内存，都调用这三个函数中的一个，那么每次都要产生系统调用开销，这是非常影响性能的；其次，这样申请的内存容易产生碎片，因为堆是从低地址到高地址，如果低地址的内存没有被释放，高地址的内存就不能被回收。

   鉴于此，malloc采用的是内存池的实现方式，malloc内存池实现方式更类似于STL分配器和memcached的内存池，先申请一大块内存，然后将内存分成不同大小的内存块，然后用户申请内存时，直接从内存池中选择一块相近的内存块即可。

5. 

   

## 计算机网络

1. TCP“粘包”问题

   产生原因：

   > 1. Nagle算法，自动收集多个小分组合并后一起发送。
   > 2. 拥塞控制，由于滑动窗口的存在，按序接收完数据后一并提交至上层。
   > 3. 数据过大，超过一次可以发送的大小限制，导致前一个包的部分数据在下一次传送。

   TCP本质是基于流的传输协议，因此并没有“粘包”的说法，解决“粘包”问题需要自行设计良好的应用层协议。

2. TCP的三次握手、四次挥手、TIME_WAIT状态。

3. select/poll/epoll

## 数据库

## C++基础



