---
title: 【CPP】移动语义
date: 2021-04-14 14:37:54
tags: CPP
---

​		在实际开发过程中，我们经常会遇到需要拷贝对象的情况，但绝大多数对象拷贝后会被立即销毁。面对这种情况，移动对象而非拷贝对象能大幅度提升性能。使用移动而非拷贝的另一个原因源于IO类或 **unique_ptr** 这样的类，这些类包含了不能被共享的资源（如指针或IO缓冲），因此这些对象不可拷贝但可以移动。

​		在旧标准中，容器中的类必须是可拷贝的，但在新标准中只要保证它们能被移动即可。

#### 1. 右值引用

​		为了支持移动操作，新标准引入了新的引用类型—右值引用。所谓右值引用即必须绑定到右值的引用，我们可以通过&&来获得右值引用。右值引用具有一个重要的特性，即只能绑定到一个即将被销毁的对象。

​		下面的例子展示了右值引用与左值引用的区别：

```c++
int i = 42;				
int &r = i;				//正确
int &&rr = i;			//错误
int &r2 = i*42;			//错误
const int &r3 = i*42;	//正确：可以将const引用绑定到一个右值上
int &&rr2 = i*42;		//正确
```

​		**左值持久，右值短暂**

​		左值具有持久的状态，而右值要么是字面常量，要么是表达式求值过程中创建的临时对象。由于右值只能绑定到临时对象，我们得知：

  - 所引用的对象将要被销毁

  - 该对象没有其他用户

    **变量是左值**

```c++
int &&rr1 = 42;
int &&rr2 = rr1; //错误，rr1是左值
```

​		**标准库move函数**

​		虽然我们不可以将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用 **move** 函数来获得绑定到左值上的右值引用。

```c++
int &&rr2 = std::move(rr1);
```

​		调用 **move** 就意味着承诺：除了对 rr1 赋值或销毁它外，我们将不再使用它。

>使用 move 的代码应该使用 std::move 而不是 move，以避免潜在的名字冲突。



#### 参考文献

[1] C++ Primer 13.6 对象移动