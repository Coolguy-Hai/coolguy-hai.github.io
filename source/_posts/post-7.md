---
title: 【Linux内核学习】《Linux内核设计与分析》第三章-进程管理
date: 2021-04-20 15:14:11
tags: Linux
---

## 进程

进程就是处于执行期的程序，通常进程还包括其他资源，如打开的文件、挂起的信号、处理器状态、一个或多个执行线程等。

执行线程是进程中活动的对象，每个线程有单独的程序计数器、进程栈和一组寄存器。内核调度的单位为线程而不是进程，Linux对进程和线程并不做区分，线程只不过一类特殊的进程。

进程在Linux中的另一个名字是任务（task）。

## 进程描述符及任务结构

内核把进程的列表存放在叫做任务队列的双向循环链表中，链表的每一项都是类型为`task_struct`、称为进程描述符的结构。进程描述符中包含的数据能完整地描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程的状态等。

#### 分配进程描述符

Linux通过slab分配器分配`task_struct`结构，这样能达到对象复用和缓存着色的目的（`cache coloring` 参见12章）。在以前的内核中，各个进程的`task_struct`放在内核栈的底部，由于现在由slab动态分配`task_struct`，所以现在在栈底或栈顶创建一个`struct thread_info`，在其中存放指向`task_struct`的指针。

#### 进程描述符的存放

在内核中，访问任务通常需要获得指向其`task_struct`的指针。因此通过`current`宏查找到当前正在运行的进程描述符的速度就显得尤为重要。在不同的机器上，该宏的实现也不同有的硬件体系结构提供了专门的寄存器来存放当前进程`task_struct`的指针。而像`x86`这样的机器，由于寄存器数量较少，就只能在内核栈的尾端创建`thread_info`结构，并在其中存放`task_struct`的指针。

#### 进程状态

进程描述符中的`state`域描述了进程的当前状态。系统的中的每个进程都必然处于五个进程状态中的一种。

- TASK_RUNNING：进程是可执行的，它或者正在执行，或者在运行队列中等待执行。
- TASK_INTERRUPTIBLE：进程正在睡眠（也就是被阻塞），等待某些条件的达成。
- TASK_UNINTERRUPTIBLE：除了就算是接收到信号也不会被唤醒或准备投入运行外，这个状态和可打断状态相同。
- __TASK_TRACED：被其他进程跟踪的进程。
- __TASK_STOPPED：进程停止运行，进程没有投入运行也不能投入运行。

#### 设置当前进程状态

内核经常需要调整某个进程的状态，这时最好使用`set_task_state(task, state)`函数。`set_current_state(state)`和`set_task_state(current, state)`含义等同。

#### 进程上下文

可执行程序的进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行，而当其执行了某个系统调用或者触发了某个异常，它就陷入了内核当中。此时，我们称内核”代表进程执行“并处于进程上下文中。在此上下文中`current`宏是有效的。

> 除了进程上下文还有中断上下文，在中断上下文中，系统不代表进程执行，而是执行一个中断处理程序。不会有进程去干扰这些中断处理程序，所以此时不存在进程上下文。（见第七章）

系统调用和异常处理程序是内核明确定义的接口，进程只有通过这些接口才能陷入内核，对内核的所有访问都必须通过这些接口。

#### 进程家族树

在Linux系统中，所有进程都是`PID`为1的`init`进程的后代。系统中的每个进程必有一个父进程，相应的，每个进程也可以拥有零个或多个子进程。

进程间的关系存放在进程描述符中。每个`task_struct`都包含一个指向其父进程`task_struct`、叫做`parent`的指针，还包含一个称为`children`的子进程链表。

## 进程创建

一般操作系统都提供了产生进程的机制：首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。Unix采用了不同的方式，它将上述步骤分解到两个单独的函数中去：`fork()`和`exec()`。首先，`fork()`通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于`PID`、`PPID`和某些资源及统计量（例如挂起的信号没有必要继承）。`exec()`函数负责读取可执行文件并将其载入地址空间开始运行。

#### 写时拷贝

传统的`fork()`系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的资源也许并不共享。更糟的是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。

因此，Linux的`fork()`使用写时拷贝页实现。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。

`fork()`的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。在一般情况下，进程创建后都会马上运行一个可执行的文件。

#### fork()

Linux通过`clone()`系统调用实现`fork()`，这个调用通过一系列的参数标志来指明父子进程需要共享的资源。`clone()`随即调用`do_fork()`，这个函数完成了创建的大部分工作。

- 创建内核栈、`thread_info`、`task_struct`。
- 设置进程描述符，使子进程与父进程区别开来，同时将状态设置为`TASK_UNINTERRUPTIBLE`，确保不会投入运行。
- 为子进程分配一个有效`PID`。
- 根据参数标志拷贝或共享资源。

函数返回后，内核通常有意选择子进程先执行，因为一般子进程都会马上调用`exec()`函数，这样可以避免写时拷贝的开销。如果父进程首先执行的话，有可能会开始向地址空间写入。

#### vfork()

除了不拷贝父进程的页表项外，`vfork()`系统调用和`fork()`的功能相同。子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，直到子进程退出或执行`exec()`。

## 线程在Linux中的实现

从内核的角度来说，它并没有线程这个概念。Linux把所有线程都当作进程来实现，内核也并没有准备特别的调度算法或是特别的数据结构来表征线程。线程仅仅是被视为一个与其他进程共享资源的进程。每个线程都拥有自己的task_struct，所以在内核看来，它就是一个普通的进程。

#### 创建线程

线程的创建和普通进程的创建类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源。

```c
clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);
```

#### 内核线程

内核线程和普通的进程间的区别在于内核线程没有独立的地址空间，是运行在内核空间中的标准进程。

## 进程终结

进程的终结大部分都要靠do_exit()来完成，一般要完成以下的工作：

- 释放内存空间。
- 减少资源的引用计数，当引用计数为0时释放资源。
- 向父进程发送信号，并为子进程重新寻找养父。
- 调用schedule()切换到新的进程。

do_exit()执行完毕后，所占有的内存就仅为内核栈、thread_info、task_struct结构。此时进程存在的唯一目的就是向父进程提供信息。

#### 删除进程描述符

#### 孤儿进程造成的进退维谷

## 小结

